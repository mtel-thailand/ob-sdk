/* tslint:disable */
/* eslint-disable */
/**
 * ob-bms
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ACRequestBody
 */
export interface ACRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ACRequestBody
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestBody
     */
    'ac_zone_id': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestBody
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestBody
     */
    'requester_id': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestBody
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof ACRequestBody
     */
    'duration': number;
}
/**
 * 
 * @export
 * @interface ACRequestQuery
 */
export interface ACRequestQuery {
    /**
     * 
     * @type {string}
     * @memberof ACRequestQuery
     */
    'requester_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestQuery
     */
    'order_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestQuery
     */
    'order_direction'?: string;
    /**
     * 
     * @type {number}
     * @memberof ACRequestQuery
     */
    'page_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ACRequestQuery
     */
    'page_size'?: number;
    /**
     * 
     * @type {ACRequestStatus}
     * @memberof ACRequestQuery
     */
    'status'?: ACRequestStatus;
}


/**
 * 
 * @export
 * @interface ACRequestResponse
 */
export interface ACRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'ac_zone_id': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'estimated_cost': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'rate': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'to': string;
    /**
     * 
     * @type {number}
     * @memberof ACRequestResponse
     */
    'duration_hour': number;
    /**
     * 
     * @type {number}
     * @memberof ACRequestResponse
     */
    'area_size': number;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ACRequestResponse
     */
    'requester_id': string;
    /**
     * 
     * @type {ACZoneData}
     * @memberof ACRequestResponse
     */
    'ac_zone': ACZoneData;
    /**
     * 
     * @type {FloorData}
     * @memberof ACRequestResponse
     */
    'floor': FloorData;
    /**
     * 
     * @type {TowerData}
     * @memberof ACRequestResponse
     */
    'tower': TowerData;
    /**
     * 
     * @type {RequesterData}
     * @memberof ACRequestResponse
     */
    'requester': RequesterData;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ACRequestStatus = {
    Submitted: 'submitted',
    Rejected: 'rejected',
    Approved: 'approved'
} as const;

export type ACRequestStatus = typeof ACRequestStatus[keyof typeof ACRequestStatus];


/**
 * 
 * @export
 * @interface ACZoneData
 */
export interface ACZoneData {
    /**
     * 
     * @type {string}
     * @memberof ACZoneData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ACZoneData
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ACZoneData
     */
    'area_size': number;
    /**
     * 
     * @type {string}
     * @memberof ACZoneData
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof ACZoneData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ACZoneData
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface CommandData
 */
export interface CommandData {
    /**
     * 
     * @type {string}
     * @memberof CommandData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandData
     */
    'name'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof CommandData
     */
    'data'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof CommandData
     */
    'status'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof CommandData
     */
    'result'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof CommandData
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandData
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandData
     */
    'member_id'?: string;
}
/**
 * 
 * @export
 * @interface CommandsCreateBody
 */
export interface CommandsCreateBody {
    /**
     * 
     * @type {string}
     * @memberof CommandsCreateBody
     */
    'name': string;
    /**
     * 
     * @type {LiftCallCommandData}
     * @memberof CommandsCreateBody
     */
    'data': LiftCallCommandData;
}
/**
 * 
 * @export
 * @interface CommandsIndexQuery
 */
export interface CommandsIndexQuery {
    /**
     * 
     * @type {string}
     * @memberof CommandsIndexQuery
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandsIndexQuery
     */
    'order_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandsIndexQuery
     */
    'order_direction'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommandsIndexQuery
     */
    'page_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandsIndexQuery
     */
    'page_size'?: number;
}
/**
 * 
 * @export
 * @interface ConsentRequestBody
 */
export interface ConsentRequestBody {
    /**
     * 
     * @type {boolean}
     * @memberof ConsentRequestBody
     */
    'consent': boolean;
}
/**
 * 
 * @export
 * @interface CreateFSMembersBody
 */
export interface CreateFSMembersBody {
    /**
     * 
     * @type {number}
     * @memberof CreateFSMembersBody
     */
    'count': number;
    /**
     * 
     * @type {Array<PersonData>}
     * @memberof CreateFSMembersBody
     */
    'data': Array<PersonData>;
}
/**
 * 
 * @export
 * @interface CreateMembersResponse
 */
export interface CreateMembersResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CreateMembersResponse
     */
    'result': boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreateMembersResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreateMembersResponse
     */
    'error': { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface CreateServiceRequestResponse
 */
export interface CreateServiceRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceRequestResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CreateVisitorBody
 */
export interface CreateVisitorBody {
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorBody
     */
    'profile_image_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorBody
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorBody
     */
    'company_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorBody
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorBody
     */
    'inviter_id': string;
    /**
     * 
     * @type {VisitorSchedule}
     * @memberof CreateVisitorBody
     */
    'visitor_schedule': VisitorSchedule;
}
/**
 * 
 * @export
 * @interface CreateVisitorResponse
 */
export interface CreateVisitorResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'profile_image_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'company_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'inviter_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVisitorResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface DestroyFSMembers
 */
export interface DestroyFSMembers {
    /**
     * 
     * @type {Array<string>}
     * @memberof DestroyFSMembers
     */
    'member_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DestroyMembersResponse
 */
export interface DestroyMembersResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DestroyMembersResponse
     */
    'result': boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DestroyMembersResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DestroyMembersResponse
     */
    'error': { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface FetchParkingResult
 */
export interface FetchParkingResult {
    /**
     * 
     * @type {boolean}
     * @memberof FetchParkingResult
     */
    'result': boolean;
    /**
     * 
     * @type {Array<SyncResultSyncJobErrorInner>}
     * @memberof FetchParkingResult
     */
    'error': Array<SyncResultSyncJobErrorInner>;
}
/**
 * 
 * @export
 * @interface FloorData
 */
export interface FloorData {
    /**
     * 
     * @type {string}
     * @memberof FloorData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof FloorData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FloorData
     */
    'tower_id': string;
    /**
     * 
     * @type {JsonValue}
     * @memberof FloorData
     */
    'display_name': JsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof FloorData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FloorData
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof FloorData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface FloorDataPasses
 */
export interface FloorDataPasses {
    /**
     * 
     * @type {string}
     * @memberof FloorDataPasses
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FloorDataPasses
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof FloorDataPasses
     */
    'name': string;
    /**
     * 
     * @type {JsonValue}
     * @memberof FloorDataPasses
     */
    'display_name': JsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof FloorDataPasses
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof FloorDataPasses
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FloorDataPasses
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface FloorSensorData
 */
export interface FloorSensorData {
    /**
     * 
     * @type {Array<SensorData>}
     * @memberof FloorSensorData
     */
    'sensors': Array<SensorData>;
    /**
     * 
     * @type {string}
     * @memberof FloorSensorData
     */
    'floor_id': string;
}
/**
 * 
 * @export
 * @interface IssueTypeData
 */
export interface IssueTypeData {
    /**
     * 
     * @type {string}
     * @memberof IssueTypeData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof IssueTypeData
     */
    'created_at': string;
    /**
     * 
     * @type {JsonValue}
     * @memberof IssueTypeData
     */
    'display_name': JsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof IssueTypeData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IssueTypeData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface JsonValue
 */
export interface JsonValue {
}
/**
 * 
 * @export
 * @interface LiftCallCommandData
 */
export interface LiftCallCommandData {
    /**
     * 
     * @type {string}
     * @memberof LiftCallCommandData
     */
    'destination_floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof LiftCallCommandData
     */
    'location_id': string;
}
/**
 * 
 * @export
 * @interface LiftCalledPayload
 */
export interface LiftCalledPayload {
    /**
     * 
     * @type {string}
     * @memberof LiftCalledPayload
     */
    'personID': string;
    /**
     * 
     * @type {string}
     * @memberof LiftCalledPayload
     */
    'liftName': string;
    /**
     * 
     * @type {string}
     * @memberof LiftCalledPayload
     */
    'floorName': string;
    /**
     * 
     * @type {string}
     * @memberof LiftCalledPayload
     */
    'towerName': string;
}
/**
 * 
 * @export
 * @interface LocationData
 */
export interface LocationData {
    /**
     * 
     * @type {number}
     * @memberof LocationData
     */
    'locationID': number;
    /**
     * 
     * @type {string}
     * @memberof LocationData
     */
    'locationName': string;
    /**
     * 
     * @type {boolean}
     * @memberof LocationData
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface LocationPasses
 */
export interface LocationPasses {
    /**
     * 
     * @type {string}
     * @memberof LocationPasses
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationPasses
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof LocationPasses
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LocationPasses
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationPasses
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationPasses
     */
    'zone_id': string;
    /**
     * 
     * @type {TowerDataPasses}
     * @memberof LocationPasses
     */
    'tower': TowerDataPasses;
    /**
     * 
     * @type {FloorDataPasses}
     * @memberof LocationPasses
     */
    'floor': FloorDataPasses;
    /**
     * 
     * @type {string}
     * @memberof LocationPasses
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LocationPasses
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface MemberIndexInterface
 */
export interface MemberIndexInterface {
    /**
     * 
     * @type {string}
     * @memberof MemberIndexInterface
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberIndexInterface
     */
    'uid'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof MemberIndexInterface
     */
    'metadata'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof MemberIndexInterface
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberIndexInterface
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberIndexInterface
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberIndexInterface
     */
    'default_floor'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberIndexInterface
     */
    'redemption_authorized': boolean;
    /**
     * 
     * @type {Tenant}
     * @memberof MemberIndexInterface
     */
    'tenant': Tenant | null;
}
/**
 * 
 * @export
 * @interface MembersPasses
 */
export interface MembersPasses {
    /**
     * 
     * @type {string}
     * @memberof MembersPasses
     */
    'uid': string;
    /**
     * 
     * @type {JsonValue}
     * @memberof MembersPasses
     */
    'metadata': JsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof MembersPasses
     */
    'account_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof MembersPasses
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof MembersPasses
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface MembersShowResponse
 */
export interface MembersShowResponse {
    /**
     * 
     * @type {string}
     * @memberof MembersShowResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MembersShowResponse
     */
    'uid': string;
    /**
     * 
     * @type {JsonValue}
     * @memberof MembersShowResponse
     */
    'metadata': JsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof MembersShowResponse
     */
    'defaultFloor': string | null;
    /**
     * 
     * @type {string}
     * @memberof MembersShowResponse
     */
    'account_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof MembersShowResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof MembersShowResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<PassData>}
     * @memberof MembersShowResponse
     */
    'passes': Array<PassData>;
    /**
     * 
     * @type {Array<TowerData>}
     * @memberof MembersShowResponse
     */
    'towers': Array<TowerData>;
    /**
     * 
     * @type {boolean}
     * @memberof MembersShowResponse
     */
    'passed_turnstile': boolean;
}
/**
 * 
 * @export
 * @interface ParkingFloorData
 */
export interface ParkingFloorData {
    /**
     * 
     * @type {string}
     * @memberof ParkingFloorData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingFloorData
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingFloorData
     */
    'name'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof ParkingFloorData
     */
    'display_name'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingFloorData
     */
    'parking_tower_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingFloorData
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingFloorData
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<ParkingLotData>}
     * @memberof ParkingFloorData
     */
    'parking_lots': Array<ParkingLotData>;
    /**
     * 
     * @type {number}
     * @memberof ParkingFloorData
     */
    'total_available_slots': number;
}
/**
 * 
 * @export
 * @interface ParkingLotData
 */
export interface ParkingLotData {
    /**
     * 
     * @type {string}
     * @memberof ParkingLotData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotData
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotData
     */
    'name'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof ParkingLotData
     */
    'display_name'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotData
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotData
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParkingLotData
     */
    'parking_floor_id'?: string;
    /**
     * 
     * @type {Array<SpotTypeData>}
     * @memberof ParkingLotData
     */
    'spot_types': Array<SpotTypeData>;
    /**
     * 
     * @type {number}
     * @memberof ParkingLotData
     */
    'total_available_slots': number;
}
/**
 * 
 * @export
 * @interface ParkingRedemptionRateResult
 */
export interface ParkingRedemptionRateResult {
    /**
     * 
     * @type {RateDetail}
     * @memberof ParkingRedemptionRateResult
     */
    'detail': RateDetail;
    /**
     * 
     * @type {number}
     * @memberof ParkingRedemptionRateResult
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface ParkingTicketData
 */
export interface ParkingTicketData {
    /**
     * 
     * @type {number}
     * @memberof ParkingTicketData
     */
    'vehicle_type_id': number;
    /**
     * 
     * @type {number}
     * @memberof ParkingTicketData
     */
    'member_type_id': number;
    /**
     * 
     * @type {RateDetail}
     * @memberof ParkingTicketData
     */
    'rate_detail': RateDetail;
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketData
     */
    'parked_at': string;
    /**
     * 
     * @type {number}
     * @memberof ParkingTicketData
     */
    'total_fee': number;
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketData
     */
    'vehicle_type': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketData
     */
    'ticket_number': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketData
     */
    'plate_number': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ParkingTicketsIndexQuery
 */
export interface ParkingTicketsIndexQuery {
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketsIndexQuery
     */
    'type': ParkingTicketsIndexQueryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketsIndexQuery
     */
    'id': string;
}

export const ParkingTicketsIndexQueryTypeEnum = {
    LogId: 'log_id',
    InviteId: 'invite_id',
    MemberId: 'member_id'
} as const;

export type ParkingTicketsIndexQueryTypeEnum = typeof ParkingTicketsIndexQueryTypeEnum[keyof typeof ParkingTicketsIndexQueryTypeEnum];

/**
 * 
 * @export
 * @interface ParkingTicketsRedeemBody
 */
export interface ParkingTicketsRedeemBody {
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketsRedeemBody
     */
    'rate_code': string;
    /**
     * 
     * @type {string}
     * @memberof ParkingTicketsRedeemBody
     */
    'redeemer_id': string;
}
/**
 * 
 * @export
 * @interface PassConsentResponse
 */
export interface PassConsentResponse {
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'uid': string | null;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'status': PassConsentResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'visitor_id': string;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'issuer_id': string;
    /**
     * 
     * @type {string}
     * @memberof PassConsentResponse
     */
    'visit_schedule_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PassConsentResponse
     */
    'consent'?: boolean | null;
}

export const PassConsentResponseStatusEnum = {
    Pending: 'pending',
    Confirmed: 'confirmed'
} as const;

export type PassConsentResponseStatusEnum = typeof PassConsentResponseStatusEnum[keyof typeof PassConsentResponseStatusEnum];

/**
 * 
 * @export
 * @interface PassData
 */
export interface PassData {
    /**
     * 
     * @type {VisitorData}
     * @memberof PassData
     */
    'visitor': VisitorData;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'status': PassDataStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'issuer_id': string;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'visit_schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'visitor_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PassData
     */
    'consent': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'uid': string | null;
    /**
     * 
     * @type {string}
     * @memberof PassData
     */
    'id': string;
}

export const PassDataStatusEnum = {
    Pending: 'pending',
    Confirmed: 'confirmed'
} as const;

export type PassDataStatusEnum = typeof PassDataStatusEnum[keyof typeof PassDataStatusEnum];

/**
 * 
 * @export
 * @interface PersonData
 */
export interface PersonData {
    /**
     * 
     * @type {string}
     * @memberof PersonData
     */
    'personID': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PersonData
     */
    'tenantIDs': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonData
     */
    'phones': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonData
     */
    'emails': Array<string>;
    /**
     * 
     * @type {Array<LocationData>}
     * @memberof PersonData
     */
    'locations': Array<LocationData>;
    /**
     * 
     * @type {string}
     * @memberof PersonData
     */
    'updateTime': string;
    /**
     * 
     * @type {boolean}
     * @memberof PersonData
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof PersonData
     */
    'status': string;
    /**
     * 
     * @type {boolean}
     * @memberof PersonData
     */
    'canPreRegister': boolean;
}
/**
 * From https://github.com/sindresorhus/type-fest/ Matches any valid JSON value.
 * @export
 * @interface PrismaJsonValue
 */
export interface PrismaJsonValue {
}
/**
 * 
 * @export
 * @interface RateDetail
 */
export interface RateDetail {
    /**
     * 
     * @type {string}
     * @memberof RateDetail
     */
    'th': string;
    /**
     * 
     * @type {string}
     * @memberof RateDetail
     */
    'en': string;
}
/**
 * 
 * @export
 * @interface RequesterData
 */
export interface RequesterData {
    /**
     * 
     * @type {string}
     * @memberof RequesterData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof RequesterData
     */
    'created_at': string;
    /**
     * 
     * @type {JsonValue}
     * @memberof RequesterData
     */
    'metadata'?: JsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof RequesterData
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RequesterData
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof RequesterData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface SensorData
 */
export interface SensorData {
    /**
     * 
     * @type {string}
     * @memberof SensorData
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof SensorData
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof SensorData
     */
    'zone_id': string;
    /**
     * 
     * @type {SensorType}
     * @memberof SensorData
     */
    'sensor_type': SensorType;
    /**
     * 
     * @type {string}
     * @memberof SensorData
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SensorData
     */
    'unit': string;
    /**
     * 
     * @type {string}
     * @memberof SensorData
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SensorType = {
    Pm25: 'pm25',
    Pm10: 'pm10',
    Co2: 'co2',
    Temperature: 'temperature',
    Humidity: 'humidity'
} as const;

export type SensorType = typeof SensorType[keyof typeof SensorType];


/**
 * 
 * @export
 * @interface SensorsIndexQuery
 */
export interface SensorsIndexQuery {
    /**
     * 
     * @type {string}
     * @memberof SensorsIndexQuery
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof SensorsIndexQuery
     */
    'member_id'?: string;
}
/**
 * 
 * @export
 * @interface ServiceRequestBody
 */
export interface ServiceRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestBody
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestBody
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestBody
     */
    'requester_id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestBody
     */
    'issue_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestBody
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestBody
     */
    'tower_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceRequestBody
     */
    'image_url': Array<string>;
}
/**
 * 
 * @export
 * @interface ServiceRequestData
 */
export interface ServiceRequestData {
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestData
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestData
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestData
     */
    'requester_id': string;
    /**
     * 
     * @type {IssueTypeData}
     * @memberof ServiceRequestData
     */
    'issue_type': IssueTypeData;
    /**
     * 
     * @type {FloorData}
     * @memberof ServiceRequestData
     */
    'floor': FloorData;
    /**
     * 
     * @type {TowerData}
     * @memberof ServiceRequestData
     */
    'tower': TowerData;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceRequestData
     */
    'image_url': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ServiceRequestQuery
 */
export interface ServiceRequestQuery {
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestQuery
     */
    'requester_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestQuery
     */
    'order_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRequestQuery
     */
    'order_direction'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceRequestQuery
     */
    'page_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceRequestQuery
     */
    'page_size'?: number;
    /**
     * 
     * @type {ServiceRequestStatus}
     * @memberof ServiceRequestQuery
     */
    'status'?: ServiceRequestStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceRequestStatus = {
    Submitted: 'submitted',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type ServiceRequestStatus = typeof ServiceRequestStatus[keyof typeof ServiceRequestStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceRequestStatusDone = {
    Done: 'done'
} as const;

export type ServiceRequestStatusDone = typeof ServiceRequestStatusDone[keyof typeof ServiceRequestStatusDone];


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceRequestStatusInProgress = {
    InProgress: 'in_progress'
} as const;

export type ServiceRequestStatusInProgress = typeof ServiceRequestStatusInProgress[keyof typeof ServiceRequestStatusInProgress];


/**
 * 
 * @export
 * @interface ServiceRequestsUpdateRequestBody
 */
export interface ServiceRequestsUpdateRequestBody {
    /**
     * 
     * @type {ServiceRequestsUpdateRequestBodyStatus}
     * @memberof ServiceRequestsUpdateRequestBody
     */
    'status': ServiceRequestsUpdateRequestBodyStatus;
}
/**
 * 
 * @export
 * @interface ServiceRequestsUpdateRequestBodyStatus
 */
export interface ServiceRequestsUpdateRequestBodyStatus {
}
/**
 * 
 * @export
 * @interface ShowPassResponse
 */
export interface ShowPassResponse {
    /**
     * 
     * @type {LocationPasses}
     * @memberof ShowPassResponse
     */
    'location': LocationPasses;
    /**
     * 
     * @type {MembersPasses}
     * @memberof ShowPassResponse
     */
    'issuer': MembersPasses;
    /**
     * 
     * @type {VisitorPasses}
     * @memberof ShowPassResponse
     */
    'visitor': VisitorPasses;
    /**
     * 
     * @type {VisitorSchedulePasses}
     * @memberof ShowPassResponse
     */
    'visitor_schedule': VisitorSchedulePasses;
    /**
     * 
     * @type {boolean}
     * @memberof ShowPassResponse
     */
    'consent'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'visit_schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'status': ShowPassResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'issuer_id': string;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'visitor_id': string;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'uid': string | null;
    /**
     * 
     * @type {string}
     * @memberof ShowPassResponse
     */
    'id': string;
}

export const ShowPassResponseStatusEnum = {
    Pending: 'pending',
    Confirmed: 'confirmed'
} as const;

export type ShowPassResponseStatusEnum = typeof ShowPassResponseStatusEnum[keyof typeof ShowPassResponseStatusEnum];

/**
 * 
 * @export
 * @interface ShowVisitorResponse
 */
export interface ShowVisitorResponse {
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'profile_image_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'company_name': string;
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'inviter_id': string;
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ShowVisitorResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface SpotTypeData
 */
export interface SpotTypeData {
    /**
     * 
     * @type {string}
     * @memberof SpotTypeData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpotTypeData
     */
    'name'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof SpotTypeData
     */
    'display_name'?: PrismaJsonValue | null;
    /**
     * 
     * @type {number}
     * @memberof SpotTypeData
     */
    'available_spots'?: number;
    /**
     * 
     * @type {string}
     * @memberof SpotTypeData
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpotTypeData
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpotTypeData
     */
    'parking_lot_id'?: string;
}
/**
 * 
 * @export
 * @interface SyncBody
 */
export interface SyncBody {
    /**
     * 
     * @type {string}
     * @memberof SyncBody
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SyncResponse
 */
export interface SyncResponse {
    /**
     * 
     * @type {SyncResult}
     * @memberof SyncResponse
     */
    'data': SyncResult;
}
/**
 * 
 * @export
 * @interface SyncResult
 */
export interface SyncResult {
    /**
     * 
     * @type {SyncResultSync}
     * @memberof SyncResult
     */
    'sync': SyncResultSync;
}
/**
 * 
 * @export
 * @interface SyncResultSync
 */
export interface SyncResultSync {
    /**
     * 
     * @type {Array<SyncResultSyncJobErrorInner>}
     * @memberof SyncResultSync
     */
    'jobError': Array<SyncResultSyncJobErrorInner>;
    /**
     * 
     * @type {boolean}
     * @memberof SyncResultSync
     */
    'result': boolean;
}
/**
 * 
 * @export
 * @interface SyncResultSyncJobErrorInner
 */
export interface SyncResultSyncJobErrorInner {
    /**
     * 
     * @type {string}
     * @memberof SyncResultSyncJobErrorInner
     */
    'uid_name': string;
    /**
     * 
     * @type {string}
     * @memberof SyncResultSyncJobErrorInner
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'name'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof Tenant
     */
    'display_name'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'address'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof Tenant
     */
    'metadata'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface TowerData
 */
export interface TowerData {
    /**
     * 
     * @type {string}
     * @memberof TowerData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof TowerData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TowerData
     */
    'project_id': string;
    /**
     * 
     * @type {JsonValue}
     * @memberof TowerData
     */
    'display_name': JsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof TowerData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TowerData
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof TowerData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TowerDataPasses
 */
export interface TowerDataPasses {
    /**
     * 
     * @type {string}
     * @memberof TowerDataPasses
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TowerDataPasses
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof TowerDataPasses
     */
    'name': string;
    /**
     * 
     * @type {JsonValue}
     * @memberof TowerDataPasses
     */
    'display_name': JsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof TowerDataPasses
     */
    'project_id': string;
    /**
     * 
     * @type {string}
     * @memberof TowerDataPasses
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TowerDataPasses
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface UpdateMemberRequestBody
 */
export interface UpdateMemberRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateMemberRequestBody
     */
    'default_floor': string;
}
/**
 * 
 * @export
 * @interface UpdateMemberResponse
 */
export interface UpdateMemberResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMemberResponse
     */
    'result': boolean | null;
}
/**
 * 
 * @export
 * @interface VisitorData
 */
export interface VisitorData {
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'inviter_id': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'company_name': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'profile_image_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface VisitorPassedPayload
 */
export interface VisitorPassedPayload {
    /**
     * 
     * @type {string}
     * @memberof VisitorPassedPayload
     */
    'inviteID': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPassedPayload
     */
    'liftName': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPassedPayload
     */
    'floorName': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPassedPayload
     */
    'towerName': string;
}
/**
 * 
 * @export
 * @interface VisitorPasses
 */
export interface VisitorPasses {
    /**
     * 
     * @type {string}
     * @memberof VisitorPasses
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPasses
     */
    'profile_image_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof VisitorPasses
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPasses
     */
    'company_name': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPasses
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPasses
     */
    'inviter_id': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPasses
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorPasses
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface VisitorSchedule
 */
export interface VisitorSchedule {
    /**
     * 
     * @type {string}
     * @memberof VisitorSchedule
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorSchedule
     */
    'floor_id': string;
    /**
     * 
     * @type {VisitorScheduleFrom}
     * @memberof VisitorSchedule
     */
    'from': VisitorScheduleFrom;
    /**
     * 
     * @type {VisitorScheduleFrom}
     * @memberof VisitorSchedule
     */
    'to': VisitorScheduleFrom;
    /**
     * 
     * @type {object}
     * @memberof VisitorSchedule
     */
    'repetition'?: object;
}
/**
 * 
 * @export
 * @interface VisitorScheduleFrom
 */
export interface VisitorScheduleFrom {
}
/**
 * 
 * @export
 * @interface VisitorSchedulePasses
 */
export interface VisitorSchedulePasses {
    /**
     * 
     * @type {string}
     * @memberof VisitorSchedulePasses
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorSchedulePasses
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorSchedulePasses
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorSchedulePasses
     */
    'to': string;
    /**
     * 
     * @type {object}
     * @memberof VisitorSchedulePasses
     */
    'repetition'?: object;
    /**
     * 
     * @type {string}
     * @memberof VisitorSchedulePasses
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorSchedulePasses
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<VisitorScheduleTokens>}
     * @memberof VisitorSchedulePasses
     */
    'tokens': Array<VisitorScheduleTokens>;
}
/**
 * 
 * @export
 * @interface VisitorScheduleTokens
 */
export interface VisitorScheduleTokens {
    /**
     * 
     * @type {string}
     * @memberof VisitorScheduleTokens
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VisitorScheduleTokens
     */
    'token_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VisitorScheduleTokens
     */
    'expired_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VisitorScheduleTokens
     */
    'visitor_schedule_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VisitorScheduleTokens
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof VisitorScheduleTokens
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface VisitorTokenData
 */
export interface VisitorTokenData {
    /**
     * 
     * @type {string}
     * @memberof VisitorTokenData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorTokenData
     */
    'token_id': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorTokenData
     */
    'expired_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof VisitorTokenData
     */
    'visitor_schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorTokenData
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorTokenData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof VisitorTokenData
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface VisitorTokensIndexQuery
 */
export interface VisitorTokensIndexQuery {
    /**
     * 
     * @type {string}
     * @memberof VisitorTokensIndexQuery
     */
    'token_id'?: string;
}
/**
 * 
 * @export
 * @interface WebhookCreateBody
 */
export interface WebhookCreateBody {
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateBody
     */
    'action': string;
    /**
     * 
     * @type {WebhookCreateBodyPayload}
     * @memberof WebhookCreateBody
     */
    'payload': WebhookCreateBodyPayload | null;
}
/**
 * 
 * @export
 * @interface WebhookCreateBodyPayload
 */
export interface WebhookCreateBodyPayload {
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateBodyPayload
     */
    'personID': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateBodyPayload
     */
    'liftName': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateBodyPayload
     */
    'floorName': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateBodyPayload
     */
    'towerName': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateBodyPayload
     */
    'inviteID': string;
}
/**
 * 
 * @export
 * @interface WrappedArrayResponseSensorsIndexResponseData
 */
export interface WrappedArrayResponseSensorsIndexResponseData {
    /**
     * 
     * @type {Array<FloorSensorData>}
     * @memberof WrappedArrayResponseSensorsIndexResponseData
     */
    'data': Array<FloorSensorData>;
}
/**
 * 
 * @export
 * @interface WrappedArrayResponseServiceRequestData
 */
export interface WrappedArrayResponseServiceRequestData {
    /**
     * 
     * @type {Array<ServiceRequestData>}
     * @memberof WrappedArrayResponseServiceRequestData
     */
    'data': Array<ServiceRequestData>;
}
/**
 * 
 * @export
 * @interface WrappedOneResponseCreateServiceRequestResponse
 */
export interface WrappedOneResponseCreateServiceRequestResponse {
    /**
     * 
     * @type {CreateServiceRequestResponse}
     * @memberof WrappedOneResponseCreateServiceRequestResponse
     */
    'data': CreateServiceRequestResponse;
}
/**
 * 
 * @export
 * @interface WrappedOneResponseServiceRequestData
 */
export interface WrappedOneResponseServiceRequestData {
    /**
     * 
     * @type {ServiceRequestData}
     * @memberof WrappedOneResponseServiceRequestData
     */
    'data': ServiceRequestData;
}
/**
 * 
 * @export
 * @interface WrappedResponseACRequestResponse
 */
export interface WrappedResponseACRequestResponse {
    /**
     * 
     * @type {WrappedResponseACRequestResponseData}
     * @memberof WrappedResponseACRequestResponse
     */
    'data': WrappedResponseACRequestResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseACRequestResponseData
 */
export interface WrappedResponseACRequestResponseData {
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'tower_id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'ac_zone_id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'estimated_cost': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'rate': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'to': string;
    /**
     * 
     * @type {number}
     * @memberof WrappedResponseACRequestResponseData
     */
    'duration_hour': number;
    /**
     * 
     * @type {number}
     * @memberof WrappedResponseACRequestResponseData
     */
    'area_size': number;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACRequestResponseData
     */
    'requester_id': string;
    /**
     * 
     * @type {ACZoneData}
     * @memberof WrappedResponseACRequestResponseData
     */
    'ac_zone': ACZoneData;
    /**
     * 
     * @type {FloorData}
     * @memberof WrappedResponseACRequestResponseData
     */
    'floor': FloorData;
    /**
     * 
     * @type {TowerData}
     * @memberof WrappedResponseACRequestResponseData
     */
    'tower': TowerData;
    /**
     * 
     * @type {RequesterData}
     * @memberof WrappedResponseACRequestResponseData
     */
    'requester': RequesterData;
}
/**
 * 
 * @export
 * @interface WrappedResponseACZoneData
 */
export interface WrappedResponseACZoneData {
    /**
     * 
     * @type {WrappedResponseACZoneDataData}
     * @memberof WrappedResponseACZoneData
     */
    'data': WrappedResponseACZoneDataData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseACZoneDataData
 */
export interface WrappedResponseACZoneDataData {
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACZoneDataData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACZoneDataData
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof WrappedResponseACZoneDataData
     */
    'area_size': number;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACZoneDataData
     */
    'floor_id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACZoneDataData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseACZoneDataData
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface WrappedResponseBoolean
 */
export interface WrappedResponseBoolean {
    /**
     * 
     * @type {WrappedResponseBooleanData}
     * @memberof WrappedResponseBoolean
     */
    'data': WrappedResponseBooleanData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseBooleanData
 */
export interface WrappedResponseBooleanData {
}
/**
 * 
 * @export
 * @interface WrappedResponseCommandsCreateResponse
 */
export interface WrappedResponseCommandsCreateResponse {
    /**
     * 
     * @type {WrappedResponseCommandsCreateResponseData}
     * @memberof WrappedResponseCommandsCreateResponse
     */
    'data': WrappedResponseCommandsCreateResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseCommandsCreateResponseData
 */
export interface WrappedResponseCommandsCreateResponseData {
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCommandsCreateResponseData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCommandsCreateResponseData
     */
    'name'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof WrappedResponseCommandsCreateResponseData
     */
    'data'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCommandsCreateResponseData
     */
    'status'?: string;
    /**
     * 
     * @type {PrismaJsonValue}
     * @memberof WrappedResponseCommandsCreateResponseData
     */
    'result'?: PrismaJsonValue | null;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCommandsCreateResponseData
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCommandsCreateResponseData
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCommandsCreateResponseData
     */
    'member_id'?: string;
}
/**
 * 
 * @export
 * @interface WrappedResponseCommandsIndexResponse
 */
export interface WrappedResponseCommandsIndexResponse {
    /**
     * 
     * @type {WrappedResponseCommandsIndexResponseData}
     * @memberof WrappedResponseCommandsIndexResponse
     */
    'data': WrappedResponseCommandsIndexResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseCommandsIndexResponseData
 */
export interface WrappedResponseCommandsIndexResponseData {
}
/**
 * 
 * @export
 * @interface WrappedResponseCreateVisitorResponse
 */
export interface WrappedResponseCreateVisitorResponse {
    /**
     * 
     * @type {WrappedResponseCreateVisitorResponseData}
     * @memberof WrappedResponseCreateVisitorResponse
     */
    'data': WrappedResponseCreateVisitorResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseCreateVisitorResponseData
 */
export interface WrappedResponseCreateVisitorResponseData {
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'profile_image_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'company_name': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'inviter_id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseCreateVisitorResponseData
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface WrappedResponseFetchParkingResult
 */
export interface WrappedResponseFetchParkingResult {
    /**
     * 
     * @type {WrappedResponseFetchParkingResultData}
     * @memberof WrappedResponseFetchParkingResult
     */
    'data': WrappedResponseFetchParkingResultData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseFetchParkingResultData
 */
export interface WrappedResponseFetchParkingResultData {
    /**
     * 
     * @type {boolean}
     * @memberof WrappedResponseFetchParkingResultData
     */
    'result': boolean;
    /**
     * 
     * @type {Array<SyncResultSyncJobErrorInner>}
     * @memberof WrappedResponseFetchParkingResultData
     */
    'error': Array<SyncResultSyncJobErrorInner>;
}
/**
 * 
 * @export
 * @interface WrappedResponseIssueTypeResponse
 */
export interface WrappedResponseIssueTypeResponse {
    /**
     * 
     * @type {WrappedResponseIssueTypeResponseData}
     * @memberof WrappedResponseIssueTypeResponse
     */
    'data': WrappedResponseIssueTypeResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseIssueTypeResponseData
 */
export interface WrappedResponseIssueTypeResponseData {
}
/**
 * 
 * @export
 * @interface WrappedResponseLocationIndexResponse
 */
export interface WrappedResponseLocationIndexResponse {
    /**
     * 
     * @type {WrappedResponseLocationIndexResponseData}
     * @memberof WrappedResponseLocationIndexResponse
     */
    'data': WrappedResponseLocationIndexResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseLocationIndexResponseData
 */
export interface WrappedResponseLocationIndexResponseData {
}
/**
 * 
 * @export
 * @interface WrappedResponseMemberIndexInterfaceArrayOrNull
 */
export interface WrappedResponseMemberIndexInterfaceArrayOrNull {
    /**
     * 
     * @type {WrappedResponseMemberIndexInterfaceArrayOrNullData}
     * @memberof WrappedResponseMemberIndexInterfaceArrayOrNull
     */
    'data': WrappedResponseMemberIndexInterfaceArrayOrNullData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseMemberIndexInterfaceArrayOrNullData
 */
export interface WrappedResponseMemberIndexInterfaceArrayOrNullData {
}
/**
 * 
 * @export
 * @interface WrappedResponseMembersShowResponseOrNull
 */
export interface WrappedResponseMembersShowResponseOrNull {
    /**
     * 
     * @type {Array<MembersShowResponse>}
     * @memberof WrappedResponseMembersShowResponseOrNull
     */
    'data': Array<MembersShowResponse> | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseNull
 */
export interface WrappedResponseNull {
    /**
     * 
     * @type {Array<number>}
     * @memberof WrappedResponseNull
     */
    'data': Array<WrappedResponseNullDataEnum>;
}

export const WrappedResponseNullDataEnum = {
    NUMBER_null: null
} as const;

export type WrappedResponseNullDataEnum = typeof WrappedResponseNullDataEnum[keyof typeof WrappedResponseNullDataEnum];

/**
 * 
 * @export
 * @interface WrappedResponseParkingLotsIndexResponse
 */
export interface WrappedResponseParkingLotsIndexResponse {
    /**
     * 
     * @type {WrappedResponseParkingLotsIndexResponseData}
     * @memberof WrappedResponseParkingLotsIndexResponse
     */
    'data': WrappedResponseParkingLotsIndexResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseParkingLotsIndexResponseData
 */
export interface WrappedResponseParkingLotsIndexResponseData {
}
/**
 * 
 * @export
 * @interface WrappedResponseParkingRedemptionRateResultArray
 */
export interface WrappedResponseParkingRedemptionRateResultArray {
    /**
     * 
     * @type {WrappedResponseParkingRedemptionRateResultArrayData}
     * @memberof WrappedResponseParkingRedemptionRateResultArray
     */
    'data': WrappedResponseParkingRedemptionRateResultArrayData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseParkingRedemptionRateResultArrayData
 */
export interface WrappedResponseParkingRedemptionRateResultArrayData {
}
/**
 * 
 * @export
 * @interface WrappedResponseParkingTicketData
 */
export interface WrappedResponseParkingTicketData {
    /**
     * 
     * @type {WrappedResponseParkingTicketDataData}
     * @memberof WrappedResponseParkingTicketData
     */
    'data': WrappedResponseParkingTicketDataData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseParkingTicketDataArray
 */
export interface WrappedResponseParkingTicketDataArray {
    /**
     * 
     * @type {WrappedResponseParkingTicketDataArrayData}
     * @memberof WrappedResponseParkingTicketDataArray
     */
    'data': WrappedResponseParkingTicketDataArrayData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseParkingTicketDataArrayData
 */
export interface WrappedResponseParkingTicketDataArrayData {
}
/**
 * 
 * @export
 * @interface WrappedResponseParkingTicketDataData
 */
export interface WrappedResponseParkingTicketDataData {
    /**
     * 
     * @type {number}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'vehicle_type_id': number;
    /**
     * 
     * @type {number}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'member_type_id': number;
    /**
     * 
     * @type {RateDetail}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'rate_detail': RateDetail;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'parked_at': string;
    /**
     * 
     * @type {number}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'total_fee': number;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'vehicle_type': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'ticket_number': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'plate_number': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseParkingTicketDataData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface WrappedResponsePassConsentResponse
 */
export interface WrappedResponsePassConsentResponse {
    /**
     * 
     * @type {WrappedResponsePassConsentResponseData}
     * @memberof WrappedResponsePassConsentResponse
     */
    'data': WrappedResponsePassConsentResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponsePassConsentResponseData
 */
export interface WrappedResponsePassConsentResponseData {
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'uid': string | null;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'status': WrappedResponsePassConsentResponseDataStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'visitor_id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'issuer_id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'visit_schedule_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof WrappedResponsePassConsentResponseData
     */
    'consent'?: boolean | null;
}

export const WrappedResponsePassConsentResponseDataStatusEnum = {
    Pending: 'pending',
    Confirmed: 'confirmed'
} as const;

export type WrappedResponsePassConsentResponseDataStatusEnum = typeof WrappedResponsePassConsentResponseDataStatusEnum[keyof typeof WrappedResponsePassConsentResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface WrappedResponseShowPassResponseOrNull
 */
export interface WrappedResponseShowPassResponseOrNull {
    /**
     * 
     * @type {Array<ShowPassResponse>}
     * @memberof WrappedResponseShowPassResponseOrNull
     */
    'data': Array<ShowPassResponse> | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseShowVisitorResponse
 */
export interface WrappedResponseShowVisitorResponse {
    /**
     * 
     * @type {WrappedResponseShowVisitorResponseData}
     * @memberof WrappedResponseShowVisitorResponse
     */
    'data': WrappedResponseShowVisitorResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseShowVisitorResponseData
 */
export interface WrappedResponseShowVisitorResponseData {
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'profile_image_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'company_name': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'inviter_id': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WrappedResponseShowVisitorResponseData
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface WrappedResponseUpdateMemberResponse
 */
export interface WrappedResponseUpdateMemberResponse {
    /**
     * 
     * @type {WrappedResponseUpdateMemberResponseData}
     * @memberof WrappedResponseUpdateMemberResponse
     */
    'data': WrappedResponseUpdateMemberResponseData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseUpdateMemberResponseData
 */
export interface WrappedResponseUpdateMemberResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof WrappedResponseUpdateMemberResponseData
     */
    'result': boolean | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseVisitorTokensIndexResponseData
 */
export interface WrappedResponseVisitorTokensIndexResponseData {
    /**
     * 
     * @type {WrappedResponseVisitorTokensIndexResponseDataData}
     * @memberof WrappedResponseVisitorTokensIndexResponseData
     */
    'data': WrappedResponseVisitorTokensIndexResponseDataData | null;
}
/**
 * 
 * @export
 * @interface WrappedResponseVisitorTokensIndexResponseDataData
 */
export interface WrappedResponseVisitorTokensIndexResponseDataData {
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ACRequestBody} aCRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acRequestCreate: async (aCRequestBody: ACRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aCRequestBody' is not null or undefined
            assertParamExists('acRequestCreate', 'aCRequestBody', aCRequestBody)
            const localVarPath = `/ac_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aCRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [requesterId] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {ACRequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acRequestIndex: async (requesterId?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, status?: ACRequestStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ac_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requesterId !== undefined) {
                localVarQueryParameter['requester_id'] = requesterId;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acRequestShow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('acRequestShow', 'id', id)
            const localVarPath = `/ac_request/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acZonesShow: async (floorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floorId' is not null or undefined
            assertParamExists('acZonesShow', 'floorId', floorId)
            const localVarPath = `/ac_zones/{floor_id}`
                .replace(`{${"floor_id"}}`, encodeURIComponent(String(floorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WebhookCreateBody} webhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (webhookCreateBody: WebhookCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookCreateBody' is not null or undefined
            assertParamExists('create', 'webhookCreateBody', webhookCreateBody)
            const localVarPath = `/integrations/fs/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetch: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/fs/parking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFSMembersBody} createFSMembersBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsFsMembersCreate: async (createFSMembersBody: CreateFSMembersBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFSMembersBody' is not null or undefined
            assertParamExists('integrationsFsMembersCreate', 'createFSMembersBody', createFSMembersBody)
            const localVarPath = `/integrations/fs/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFSMembersBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DestroyFSMembers} destroyFSMembers 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsFsMembersDelete: async (destroyFSMembers: DestroyFSMembers, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destroyFSMembers' is not null or undefined
            assertParamExists('integrationsFsMembersDelete', 'destroyFSMembers', destroyFSMembers)
            const localVarPath = `/integrations/fs/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destroyFSMembers, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueTypesIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/issue_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} memberId 
         * @param {CommandsCreateBody} commandsCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersCommandsCreate: async (memberId: string, commandsCreateBody: CommandsCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('membersCommandsCreate', 'memberId', memberId)
            // verify required parameter 'commandsCreateBody' is not null or undefined
            assertParamExists('membersCommandsCreate', 'commandsCreateBody', commandsCreateBody)
            const localVarPath = `/members/{member_id}/commands`
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandsCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} memberId 
         * @param {string} [name] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersCommandsIndex: async (memberId: string, name?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('membersCommandsIndex', 'memberId', memberId)
            const localVarPath = `/members/{member_id}/commands`
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [identifier] 
         * @param {string} [accountId] 
         * @param {string} [xAccountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersIndex: async (identifier?: string, accountId?: string, xAccountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (identifier !== undefined) {
                localVarQueryParameter['identifier'] = identifier;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (xAccountId != null) {
                localVarHeaderParameter['x-account-id'] = String(xAccountId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [locationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersShow: async (id: string, locationId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('membersShow', 'id', id)
            const localVarPath = `/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (locationId !== undefined) {
                localVarQueryParameter['location_id'] = locationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMemberRequestBody} updateMemberRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersUpdate: async (id: string, updateMemberRequestBody: UpdateMemberRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('membersUpdate', 'id', id)
            // verify required parameter 'updateMemberRequestBody' is not null or undefined
            assertParamExists('membersUpdate', 'updateMemberRequestBody', updateMemberRequestBody)
            const localVarPath = `/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parkingLotsIndex: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/parking_lots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} memberTypeId 
         * @param {number} vehicleTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parkingRedemptionRatesIndex: async (id: string, memberTypeId: number, vehicleTypeId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('parkingRedemptionRatesIndex', 'id', id)
            // verify required parameter 'memberTypeId' is not null or undefined
            assertParamExists('parkingRedemptionRatesIndex', 'memberTypeId', memberTypeId)
            // verify required parameter 'vehicleTypeId' is not null or undefined
            assertParamExists('parkingRedemptionRatesIndex', 'vehicleTypeId', vehicleTypeId)
            const localVarPath = `/members/{id}/parking_redemption_rates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (memberTypeId !== undefined) {
                localVarQueryParameter['member_type_id'] = memberTypeId;
            }

            if (vehicleTypeId !== undefined) {
                localVarQueryParameter['vehicle_type_id'] = vehicleTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParkingTicketsIndexTypeEnum} type 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parkingTicketsIndex: async (type: ParkingTicketsIndexTypeEnum, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('parkingTicketsIndex', 'type', type)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('parkingTicketsIndex', 'id', id)
            const localVarPath = `/parking_tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} logId 
         * @param {ParkingTicketsRedeemBody} parkingTicketsRedeemBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parkingTicketsRedeem: async (logId: string, parkingTicketsRedeemBody: ParkingTicketsRedeemBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logId' is not null or undefined
            assertParamExists('parkingTicketsRedeem', 'logId', logId)
            // verify required parameter 'parkingTicketsRedeemBody' is not null or undefined
            assertParamExists('parkingTicketsRedeem', 'parkingTicketsRedeemBody', parkingTicketsRedeemBody)
            const localVarPath = `/parking_tickets/{log_id}/redeem`
                .replace(`{${"log_id"}}`, encodeURIComponent(String(logId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parkingTicketsRedeemBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} visitScheduleId 
         * @param {ConsentRequestBody} consentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passesConsent: async (visitScheduleId: string, consentRequestBody: ConsentRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'visitScheduleId' is not null or undefined
            assertParamExists('passesConsent', 'visitScheduleId', visitScheduleId)
            // verify required parameter 'consentRequestBody' is not null or undefined
            assertParamExists('passesConsent', 'consentRequestBody', consentRequestBody)
            const localVarPath = `/passes/consent/{visit_schedule_id}`
                .replace(`{${"visit_schedule_id"}}`, encodeURIComponent(String(visitScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(consentRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} visitScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passesShow: async (visitScheduleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'visitScheduleId' is not null or undefined
            assertParamExists('passesShow', 'visitScheduleId', visitScheduleId)
            const localVarPath = `/passes/{visit_schedule_id}`
                .replace(`{${"visit_schedule_id"}}`, encodeURIComponent(String(visitScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} towerId 
         * @param {string} [memberId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sensorsIndex: async (towerId: string, memberId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'towerId' is not null or undefined
            assertParamExists('sensorsIndex', 'towerId', towerId)
            const localVarPath = `/sensors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (towerId !== undefined) {
                localVarQueryParameter['tower_id'] = towerId;
            }

            if (memberId !== undefined) {
                localVarQueryParameter['member_id'] = memberId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServiceRequestBody} serviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRequestsCreate: async (serviceRequestBody: ServiceRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceRequestBody' is not null or undefined
            assertParamExists('serviceRequestsCreate', 'serviceRequestBody', serviceRequestBody)
            const localVarPath = `/service_requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [requesterId] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {ServiceRequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRequestsIndex: async (requesterId?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, status?: ServiceRequestStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requesterId !== undefined) {
                localVarQueryParameter['requester_id'] = requesterId;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRequestsShow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceRequestsShow', 'id', id)
            const localVarPath = `/service_requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceRequestsUpdateRequestBody} serviceRequestsUpdateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRequestsUpdate: async (id: string, serviceRequestsUpdateRequestBody: ServiceRequestsUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceRequestsUpdate', 'id', id)
            // verify required parameter 'serviceRequestsUpdateRequestBody' is not null or undefined
            assertParamExists('serviceRequestsUpdate', 'serviceRequestsUpdateRequestBody', serviceRequestsUpdateRequestBody)
            const localVarPath = `/service_requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceRequestsUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SyncBody} syncBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync: async (syncBody: SyncBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncBody' is not null or undefined
            assertParamExists('sync', 'syncBody', syncBody)
            const localVarPath = `/integrations/fs/job/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [tokenId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitorTokensIndex: async (tokenId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/visitor_tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateVisitorBody} createVisitorBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitorsCreate: async (createVisitorBody: CreateVisitorBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVisitorBody' is not null or undefined
            assertParamExists('visitorsCreate', 'createVisitorBody', createVisitorBody)
            const localVarPath = `/visitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVisitorBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitorsDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('visitorsDestroy', 'id', id)
            const localVarPath = `/visitors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitorsShow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('visitorsShow', 'id', id)
            const localVarPath = `/visitors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ACRequestBody} aCRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acRequestCreate(aCRequestBody: ACRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acRequestCreate(aCRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [requesterId] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {ACRequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acRequestIndex(requesterId?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, status?: ACRequestStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseACRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acRequestIndex(requesterId, orderBy, orderDirection, pageNumber, pageSize, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acRequestShow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseACRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acRequestShow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} floorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acZonesShow(floorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseACZoneData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acZonesShow(floorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WebhookCreateBody} webhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(webhookCreateBody: WebhookCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(webhookCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetch(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseFetchParkingResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetch(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateFSMembersBody} createFSMembersBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsFsMembersCreate(createFSMembersBody: CreateFSMembersBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsFsMembersCreate(createFSMembersBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DestroyFSMembers} destroyFSMembers 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsFsMembersDelete(destroyFSMembers: DestroyFSMembers, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DestroyMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsFsMembersDelete(destroyFSMembers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueTypesIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseIssueTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueTypesIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationsIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseLocationIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationsIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} memberId 
         * @param {CommandsCreateBody} commandsCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersCommandsCreate(memberId: string, commandsCreateBody: CommandsCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseCommandsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersCommandsCreate(memberId, commandsCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} memberId 
         * @param {string} [name] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersCommandsIndex(memberId: string, name?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseCommandsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersCommandsIndex(memberId, name, orderBy, orderDirection, pageNumber, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [identifier] 
         * @param {string} [accountId] 
         * @param {string} [xAccountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersIndex(identifier?: string, accountId?: string, xAccountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseMemberIndexInterfaceArrayOrNull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersIndex(identifier, accountId, xAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [locationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersShow(id: string, locationId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseMembersShowResponseOrNull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersShow(id, locationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMemberRequestBody} updateMemberRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membersUpdate(id: string, updateMemberRequestBody: UpdateMemberRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseUpdateMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membersUpdate(id, updateMemberRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parkingLotsIndex(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseParkingLotsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parkingLotsIndex(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} memberTypeId 
         * @param {number} vehicleTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parkingRedemptionRatesIndex(id: string, memberTypeId: number, vehicleTypeId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseParkingRedemptionRateResultArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parkingRedemptionRatesIndex(id, memberTypeId, vehicleTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ParkingTicketsIndexTypeEnum} type 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parkingTicketsIndex(type: ParkingTicketsIndexTypeEnum, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseParkingTicketDataArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parkingTicketsIndex(type, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} logId 
         * @param {ParkingTicketsRedeemBody} parkingTicketsRedeemBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parkingTicketsRedeem(logId: string, parkingTicketsRedeemBody: ParkingTicketsRedeemBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseParkingTicketData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parkingTicketsRedeem(logId, parkingTicketsRedeemBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} visitScheduleId 
         * @param {ConsentRequestBody} consentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passesConsent(visitScheduleId: string, consentRequestBody: ConsentRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponsePassConsentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passesConsent(visitScheduleId, consentRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} visitScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passesShow(visitScheduleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseShowPassResponseOrNull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passesShow(visitScheduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} towerId 
         * @param {string} [memberId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sensorsIndex(towerId: string, memberId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedArrayResponseSensorsIndexResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sensorsIndex(towerId, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ServiceRequestBody} serviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRequestsCreate(serviceRequestBody: ServiceRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedOneResponseCreateServiceRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRequestsCreate(serviceRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [requesterId] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {ServiceRequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRequestsIndex(requesterId?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, status?: ServiceRequestStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedArrayResponseServiceRequestData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRequestsIndex(requesterId, orderBy, orderDirection, pageNumber, pageSize, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRequestsShow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedOneResponseServiceRequestData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRequestsShow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceRequestsUpdateRequestBody} serviceRequestsUpdateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRequestsUpdate(id: string, serviceRequestsUpdateRequestBody: ServiceRequestsUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedOneResponseServiceRequestData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRequestsUpdate(id, serviceRequestsUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SyncBody} syncBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sync(syncBody: SyncBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sync(syncBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [tokenId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async visitorTokensIndex(tokenId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseVisitorTokensIndexResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.visitorTokensIndex(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateVisitorBody} createVisitorBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async visitorsCreate(createVisitorBody: CreateVisitorBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseCreateVisitorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.visitorsCreate(createVisitorBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async visitorsDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseNull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.visitorsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async visitorsShow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrappedResponseShowVisitorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.visitorsShow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {ACRequestBody} aCRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acRequestCreate(aCRequestBody: ACRequestBody, options?: any): AxiosPromise<WrappedResponseBoolean> {
            return localVarFp.acRequestCreate(aCRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [requesterId] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {ACRequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acRequestIndex(requesterId?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, status?: ACRequestStatus, options?: any): AxiosPromise<WrappedResponseACRequestResponse> {
            return localVarFp.acRequestIndex(requesterId, orderBy, orderDirection, pageNumber, pageSize, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acRequestShow(id: string, options?: any): AxiosPromise<WrappedResponseACRequestResponse> {
            return localVarFp.acRequestShow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acZonesShow(floorId: string, options?: any): AxiosPromise<WrappedResponseACZoneData> {
            return localVarFp.acZonesShow(floorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WebhookCreateBody} webhookCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(webhookCreateBody: WebhookCreateBody, options?: any): AxiosPromise<void> {
            return localVarFp.create(webhookCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetch(options?: any): AxiosPromise<WrappedResponseFetchParkingResult> {
            return localVarFp.fetch(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateFSMembersBody} createFSMembersBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsFsMembersCreate(createFSMembersBody: CreateFSMembersBody, options?: any): AxiosPromise<CreateMembersResponse> {
            return localVarFp.integrationsFsMembersCreate(createFSMembersBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DestroyFSMembers} destroyFSMembers 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsFsMembersDelete(destroyFSMembers: DestroyFSMembers, options?: any): AxiosPromise<DestroyMembersResponse> {
            return localVarFp.integrationsFsMembersDelete(destroyFSMembers, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueTypesIndex(options?: any): AxiosPromise<WrappedResponseIssueTypeResponse> {
            return localVarFp.issueTypesIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsIndex(options?: any): AxiosPromise<WrappedResponseLocationIndexResponse> {
            return localVarFp.locationsIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} memberId 
         * @param {CommandsCreateBody} commandsCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersCommandsCreate(memberId: string, commandsCreateBody: CommandsCreateBody, options?: any): AxiosPromise<WrappedResponseCommandsCreateResponse> {
            return localVarFp.membersCommandsCreate(memberId, commandsCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} memberId 
         * @param {string} [name] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersCommandsIndex(memberId: string, name?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, options?: any): AxiosPromise<WrappedResponseCommandsIndexResponse> {
            return localVarFp.membersCommandsIndex(memberId, name, orderBy, orderDirection, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [identifier] 
         * @param {string} [accountId] 
         * @param {string} [xAccountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersIndex(identifier?: string, accountId?: string, xAccountId?: string, options?: any): AxiosPromise<WrappedResponseMemberIndexInterfaceArrayOrNull> {
            return localVarFp.membersIndex(identifier, accountId, xAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [locationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersShow(id: string, locationId?: string, options?: any): AxiosPromise<WrappedResponseMembersShowResponseOrNull> {
            return localVarFp.membersShow(id, locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMemberRequestBody} updateMemberRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membersUpdate(id: string, updateMemberRequestBody: UpdateMemberRequestBody, options?: any): AxiosPromise<WrappedResponseUpdateMemberResponse> {
            return localVarFp.membersUpdate(id, updateMemberRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parkingLotsIndex(options?: any): AxiosPromise<WrappedResponseParkingLotsIndexResponse> {
            return localVarFp.parkingLotsIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} memberTypeId 
         * @param {number} vehicleTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parkingRedemptionRatesIndex(id: string, memberTypeId: number, vehicleTypeId: number, options?: any): AxiosPromise<WrappedResponseParkingRedemptionRateResultArray> {
            return localVarFp.parkingRedemptionRatesIndex(id, memberTypeId, vehicleTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ParkingTicketsIndexTypeEnum} type 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parkingTicketsIndex(type: ParkingTicketsIndexTypeEnum, id: string, options?: any): AxiosPromise<WrappedResponseParkingTicketDataArray> {
            return localVarFp.parkingTicketsIndex(type, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} logId 
         * @param {ParkingTicketsRedeemBody} parkingTicketsRedeemBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parkingTicketsRedeem(logId: string, parkingTicketsRedeemBody: ParkingTicketsRedeemBody, options?: any): AxiosPromise<WrappedResponseParkingTicketData> {
            return localVarFp.parkingTicketsRedeem(logId, parkingTicketsRedeemBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} visitScheduleId 
         * @param {ConsentRequestBody} consentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passesConsent(visitScheduleId: string, consentRequestBody: ConsentRequestBody, options?: any): AxiosPromise<WrappedResponsePassConsentResponse> {
            return localVarFp.passesConsent(visitScheduleId, consentRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} visitScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passesShow(visitScheduleId: string, options?: any): AxiosPromise<WrappedResponseShowPassResponseOrNull> {
            return localVarFp.passesShow(visitScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} towerId 
         * @param {string} [memberId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sensorsIndex(towerId: string, memberId?: string, options?: any): AxiosPromise<WrappedArrayResponseSensorsIndexResponseData> {
            return localVarFp.sensorsIndex(towerId, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServiceRequestBody} serviceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRequestsCreate(serviceRequestBody: ServiceRequestBody, options?: any): AxiosPromise<WrappedOneResponseCreateServiceRequestResponse> {
            return localVarFp.serviceRequestsCreate(serviceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [requesterId] 
         * @param {string} [orderBy] 
         * @param {string} [orderDirection] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {ServiceRequestStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRequestsIndex(requesterId?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, status?: ServiceRequestStatus, options?: any): AxiosPromise<WrappedArrayResponseServiceRequestData> {
            return localVarFp.serviceRequestsIndex(requesterId, orderBy, orderDirection, pageNumber, pageSize, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRequestsShow(id: string, options?: any): AxiosPromise<WrappedOneResponseServiceRequestData> {
            return localVarFp.serviceRequestsShow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ServiceRequestsUpdateRequestBody} serviceRequestsUpdateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRequestsUpdate(id: string, serviceRequestsUpdateRequestBody: ServiceRequestsUpdateRequestBody, options?: any): AxiosPromise<WrappedOneResponseServiceRequestData> {
            return localVarFp.serviceRequestsUpdate(id, serviceRequestsUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SyncBody} syncBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync(syncBody: SyncBody, options?: any): AxiosPromise<SyncResponse> {
            return localVarFp.sync(syncBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [tokenId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitorTokensIndex(tokenId?: string, options?: any): AxiosPromise<WrappedResponseVisitorTokensIndexResponseData> {
            return localVarFp.visitorTokensIndex(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateVisitorBody} createVisitorBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitorsCreate(createVisitorBody: CreateVisitorBody, options?: any): AxiosPromise<WrappedResponseCreateVisitorResponse> {
            return localVarFp.visitorsCreate(createVisitorBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitorsDestroy(id: string, options?: any): AxiosPromise<WrappedResponseNull> {
            return localVarFp.visitorsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitorsShow(id: string, options?: any): AxiosPromise<WrappedResponseShowVisitorResponse> {
            return localVarFp.visitorsShow(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {ACRequestBody} aCRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public acRequestCreate(aCRequestBody: ACRequestBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).acRequestCreate(aCRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [requesterId] 
     * @param {string} [orderBy] 
     * @param {string} [orderDirection] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {ACRequestStatus} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public acRequestIndex(requesterId?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, status?: ACRequestStatus, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).acRequestIndex(requesterId, orderBy, orderDirection, pageNumber, pageSize, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public acRequestShow(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).acRequestShow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public acZonesShow(floorId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).acZonesShow(floorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WebhookCreateBody} webhookCreateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public create(webhookCreateBody: WebhookCreateBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).create(webhookCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fetch(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).fetch(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateFSMembersBody} createFSMembersBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public integrationsFsMembersCreate(createFSMembersBody: CreateFSMembersBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).integrationsFsMembersCreate(createFSMembersBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DestroyFSMembers} destroyFSMembers 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public integrationsFsMembersDelete(destroyFSMembers: DestroyFSMembers, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).integrationsFsMembersDelete(destroyFSMembers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public issueTypesIndex(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).issueTypesIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public locationsIndex(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).locationsIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} memberId 
     * @param {CommandsCreateBody} commandsCreateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public membersCommandsCreate(memberId: string, commandsCreateBody: CommandsCreateBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).membersCommandsCreate(memberId, commandsCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} memberId 
     * @param {string} [name] 
     * @param {string} [orderBy] 
     * @param {string} [orderDirection] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public membersCommandsIndex(memberId: string, name?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).membersCommandsIndex(memberId, name, orderBy, orderDirection, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [identifier] 
     * @param {string} [accountId] 
     * @param {string} [xAccountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public membersIndex(identifier?: string, accountId?: string, xAccountId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).membersIndex(identifier, accountId, xAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [locationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public membersShow(id: string, locationId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).membersShow(id, locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMemberRequestBody} updateMemberRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public membersUpdate(id: string, updateMemberRequestBody: UpdateMemberRequestBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).membersUpdate(id, updateMemberRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public parkingLotsIndex(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).parkingLotsIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} memberTypeId 
     * @param {number} vehicleTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public parkingRedemptionRatesIndex(id: string, memberTypeId: number, vehicleTypeId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).parkingRedemptionRatesIndex(id, memberTypeId, vehicleTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ParkingTicketsIndexTypeEnum} type 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public parkingTicketsIndex(type: ParkingTicketsIndexTypeEnum, id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).parkingTicketsIndex(type, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} logId 
     * @param {ParkingTicketsRedeemBody} parkingTicketsRedeemBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public parkingTicketsRedeem(logId: string, parkingTicketsRedeemBody: ParkingTicketsRedeemBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).parkingTicketsRedeem(logId, parkingTicketsRedeemBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} visitScheduleId 
     * @param {ConsentRequestBody} consentRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public passesConsent(visitScheduleId: string, consentRequestBody: ConsentRequestBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).passesConsent(visitScheduleId, consentRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} visitScheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public passesShow(visitScheduleId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).passesShow(visitScheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} towerId 
     * @param {string} [memberId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sensorsIndex(towerId: string, memberId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sensorsIndex(towerId, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceRequestBody} serviceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public serviceRequestsCreate(serviceRequestBody: ServiceRequestBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).serviceRequestsCreate(serviceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [requesterId] 
     * @param {string} [orderBy] 
     * @param {string} [orderDirection] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {ServiceRequestStatus} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public serviceRequestsIndex(requesterId?: string, orderBy?: string, orderDirection?: string, pageNumber?: number, pageSize?: number, status?: ServiceRequestStatus, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).serviceRequestsIndex(requesterId, orderBy, orderDirection, pageNumber, pageSize, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public serviceRequestsShow(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).serviceRequestsShow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ServiceRequestsUpdateRequestBody} serviceRequestsUpdateRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public serviceRequestsUpdate(id: string, serviceRequestsUpdateRequestBody: ServiceRequestsUpdateRequestBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).serviceRequestsUpdate(id, serviceRequestsUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncBody} syncBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sync(syncBody: SyncBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sync(syncBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [tokenId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public visitorTokensIndex(tokenId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).visitorTokensIndex(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateVisitorBody} createVisitorBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public visitorsCreate(createVisitorBody: CreateVisitorBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).visitorsCreate(createVisitorBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public visitorsDestroy(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).visitorsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public visitorsShow(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).visitorsShow(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ParkingTicketsIndexTypeEnum = {
    LogId: 'log_id',
    InviteId: 'invite_id',
    MemberId: 'member_id'
} as const;
export type ParkingTicketsIndexTypeEnum = typeof ParkingTicketsIndexTypeEnum[keyof typeof ParkingTicketsIndexTypeEnum];


